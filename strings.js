"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Generated by CoffeeScript 2.5.1
(function () {
  // strings.coffee - A Javascript string manipulation library, written in Coffeescript.
  // MIT License
  // Copyright (c) 2014 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  "use strict";

  var Chars,
      Strings,
      Types,
      _,
      asciiStringType,
      changeCase,
      mapStringToNumber,
      type,
      indexOf = [].indexOf;

  Types = require('types.js'); // returns the amount of successful parseInt's on array

  mapStringToNumber = function mapStringToNumber(array) {
    var index, j, len, nr, value;

    if (_.notArray(array)) {
      return 0;
    }

    for (index = j = 0, len = array.length; j < len; index = ++j) {
      value = array[index];
      nr = _.forceNumber(value);

      if (nr["void"]) {
        return index;
      }

      array[index] = nr;
    }

    return array.length;
  }; //															_ (selection of tools)


  _ = /*#__PURE__*/function () {
    _createClass(_, null, [{
      key: "inRange",
      value: function inRange(nr, range) {
        if (Types.isNaN(nr = parseInt(nr, 10)) || mapStringToNumber(range) < 2) {
          return false;
        }

        return nr >= range[0] && nr <= range[1];
      }
    }, {
      key: "limitNumber",
      value: function limitNumber(nr, range) {
        nr = Types.forceNumber(nr, 0);

        if (mapStringToNumber(range) < 2) {
          return nr;
        }

        if (nr < range[0]) {
          return range[0];
        }

        if (nr > range[1]) {
          return range[1];
        }

        return nr;
      }
    }, {
      key: "randomNumber",
      value: function randomNumber(min, max) {
        if (mapStringToNumber([min, max]) < 2) {
          return 0;
        }

        if (max < min) {
          return min;
        }

        max = max - min + 1;
        return Math.floor(Math.random() * max + min);
      }
    }, {
      key: "shuffleArray",
      value: function shuffleArray(array) {
        var i, j, length, rand, ref, temp;

        if (Types.notArray(array) || array.length < 1) {
          return [];
        }

        length = array.length - 1;

        for (i = j = ref = length; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
          rand = _.randomNumber(0, i);
          temp = array[i];
          array[i] = array[rand];
          array[rand] = temp;
        }

        return array;
      }
    }, {
      key: "positiveIndex",
      value: function positiveIndex(index, max) {
        if (0 === (index = Types.forceNumber(index, 0))) {
          return false;
        }

        max = Math.abs(Types.forceNumber(max));

        if (Math.abs(index) <= max) {
          if (index > 0) {
            return index - 1;
          }

          return max + index;
        }

        return false;
      }
    }, {
      key: "insertSort",
      value: function insertSort(array) {
        var current, index, j, length, prev, ref;
        length = array.length - 1;

        for (index = j = 1, ref = length; 1 <= ref ? j <= ref : j >= ref; index = 1 <= ref ? ++j : --j) {
          current = array[index];
          prev = index - 1;

          while (prev >= 0 && array[prev] > current) {
            array[prev + 1] = array[prev];
            --prev;
          }

          array[+prev + 1] = current;
        }

        return array;
      } // only for sorted arrays

    }, {
      key: "noDupAndReverse",
      value: function noDupAndReverse(array) {
        var index, j, length, newArr, ref;
        length = array.length - 1;
        newArr = [];

        for (index = j = ref = length; ref <= 0 ? j <= 0 : j >= 0; index = ref <= 0 ? ++j : --j) {
          if (newArr[newArr.length - 1] !== array[index]) {
            newArr.push(array[index]);
          }
        }

        return newArr;
      } // process arguments list to contain only positive indexes, sorted, reversed order, and duplicates removed

    }, {
      key: "sortNoDupAndReverse",
      value: function sortNoDupAndReverse(array, maxLength) {
        var index, j, len, processed, value;
        processed = [];

        for (index = j = 0, len = array.length; j < len; index = ++j) {
          value = array[index];
          value = Types.forceNumber(value);

          if (value["void"]) {
            continue;
          }

          if (value <= maxLength) {
            value = _.positiveIndex(value, maxLength);
          }

          processed.push(Types.forceNumber(value, 0));
        }

        return _.noDupAndReverse(_.insertSort(processed));
      }
    }]);

    function _() {
      _classCallCheck(this, _);
    }

    return _;
  }(); // copy types.js as static methods into _


  for (type in Types) {
    _[type] = Types[type];
  }

  Chars = function () {
    //																	Chars (selection of chars.js)
    var Chars = /*#__PURE__*/function (_ref) {
      _inherits(Chars, _ref);

      var _super = _createSuper(Chars);

      _createClass(Chars, null, [{
        key: "ascii",
        value: function ascii(ordinal) {
          return String.fromCharCode(_.forceNumber(ordinal));
        }
      }, {
        key: "ordinal",
        value: function ordinal(_char) {
          return _.forceNumber(_.forceString(_char).charCodeAt(), 0);
        }
      }, {
        key: "random",
        value: function random(range) {
          var max, min;

          if (!_.isArray(range) || range.length < 2) {
            range = Chars.ASCII_RANGE_ALL;
          }

          min = _.limitNumber(range[0], range);
          max = _.limitNumber(range[1], range);
          return Chars.ascii(_.randomNumber(min, max));
        }
      }]);

      function Chars() {
        _classCallCheck(this, Chars);

        return _super.call(this);
      }

      return Chars;
    }(_);

    ;
    Chars.ASCII_RANGE_UPPERCASE = [65, 90];
    Chars.ASCII_RANGE_LOWERCASE = [97, 122];
    Chars.ASCII_RANGE_NUMBERS = [48, 57];
    Chars.ASCII_RANGE_SPECIAL_1 = [32, 47];
    Chars.ASCII_RANGE_SPECIAL_2 = [58, 64];
    Chars.ASCII_RANGE_SPECIAL_3 = [91, 96];
    Chars.ASCII_RANGE_SPECIAL_4 = [123, 126];
    Chars.ASCII_RANGE_ALL = [32, 126];
    Chars.REGEXP_SPECIAL_CHARS = ['?', '\\', '[', ']', '(', ')', '*', '+', '.', '/', '|', '^', '$', '<', '>', '-', '&'];
    return Chars;
  }.call(this); //																	Strings
  // refactor this later, and get rid of the ..., arguments[n] are ~10 times faster.


  changeCase = function changeCase() {
    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var caseMethod = arguments.length > 1 ? arguments[1] : undefined;
    var arg, j, k, len, len1, pos;

    if ('' === (string = _.forceString(string))) {
      return string;
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (args.length < 1 || args[0] === void 0) {
      return string[caseMethod]();
    } else if (_.isNumber(args[0])) {
      for (j = 0, len = args.length; j < len; j++) {
        arg = args[j];
        pos = _.positiveIndex(arg, string.length);
        string = Strings.xs(string, function (_char2, index) {
          if (index === pos) {
            return _char2[caseMethod]();
          }

          return _char2;
        });
      }
    } else if (_.isString(args[0])) {
      for (k = 0, len1 = args.length; k < len1; k++) {
        arg = args[k];
        string = Strings.replace(string, arg, arg[caseMethod](), 'gi');
      }
    }

    return string;
  };

  asciiStringType = function asciiStringType(string, method) {
    var _char3, j, len;

    if ('' === (string = _.forceString(string))) {
      return false;
    }

    for (j = 0, len = string.length; j < len; j++) {
      _char3 = string[j];

      if (!method(_char3)) {
        return false;
      }
    }

    return true;
  };

  Strings = function () {
    var Strings = /*#__PURE__*/function (_Chars) {
      _inherits(Strings, _Chars);

      var _super2 = _createSuper(Strings);

      _createClass(Strings, null, [{
        key: "create",
        value: function create() {
          var arg, j, len, string;
          string = '';

          for (j = 0, len = arguments.length; j < len; j++) {
            arg = arguments[j];
            string += _.forceString(arg);
          }

          return string;
        }
      }, {
        key: "get",
        value: function get(string) {
          for (var _len2 = arguments.length, positions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            positions[_key2 - 1] = arguments[_key2];
          }

          var argsLength, j, length, pos, ref, result;

          if (arguments.length < 2) {
            return '';
          }

          string = _.forceString(string);
          length = string.length;
          result = '';
          argsLength = arguments.length;

          for (pos = j = 1, ref = argsLength; 1 <= ref ? j <= ref : j >= ref; pos = 1 <= ref ? ++j : --j) {
            pos = _.positiveIndex(arguments[pos], length);

            if (pos !== false) {
              result += string[pos];
            }
          }

          return result;
        }
      }, {
        key: "sort",
        value: function sort(string) {
          string = _.forceString(string).trim().split('');
          return _.insertSort(string).join('');
        }
      }, {
        key: "random",
        value: function random(amount, charSet) {
          var i, j, ref, string;
          amount = _.forceNumber(amount, 1);
          string = '';

          for (i = j = 1, ref = amount; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
            string += Chars.random(charSet);
          }

          return string;
        }
      }, {
        key: "times",
        value: function times(string, amount) {
          var multi;

          if ('' === (string = _.forceString(string))) {
            return '';
          }

          amount = _.forceNumber(amount, 1);
          multi = '';

          while (amount-- > 0) {
            multi += string;
          }

          return multi;
        }
      }, {
        key: "regEscape",
        value: function regEscape(string) {
          if ('' === (string = _.forceString(string))) {
            return string;
          }

          return Strings.xs(string, function (_char4) {
            if (indexOf.call(Chars.REGEXP_SPECIAL_CHARS, _char4) >= 0) {
              return '\\' + _char4;
            }

            return true;
          });
        }
      }, {
        key: "empty",
        value: function empty(string) {
          if (_.notString(string) || string.length > 0) {
            return false;
          }

          return true;
        }
      }, {
        key: "isAlpha",
        value: function isAlpha(string) {
          if ('' === (string = _.forceString(string))) {
            return false;
          }

          return /^[a-z]*$/ig.test(string);
        }
      }, {
        key: "isNumeric",
        value: function isNumeric(string) {
          if ('' === (string = _.forceString(string))) {
            return false;
          }

          return /^[0-9]*$/g.test(string);
        }
      }, {
        key: "isAlphaNumeric",
        value: function isAlphaNumeric(string) {
          if ('' === (string = _.forceString(string))) {
            return false;
          }

          return /^[0-9|a-z]*$/ig.test(string);
        }
      }, {
        key: "isSpecial",
        value: function isSpecial(string) {
          if ('' === (string = _.forceString(string))) {
            return false;
          }

          return /^[^0-9|a-z]*$/ig.test(string);
        }
      }, {
        key: "isSpace",
        value: function isSpace(string) {
          return /^[ \t]+$/g.test(string);
        }
      }, {
        key: "hasUpper",
        value: function hasUpper(string) {
          return /[A-Z]+/g.test(string);
        }
      }, {
        key: "isUpper",
        value: function isUpper(string) {
          return /^[A-Z]+$/g.test(string);
        }
      }, {
        key: "isLower",
        value: function isLower(string) {
          return /^[a-z]+$/g.test(string);
        }
      }, {
        key: "xs",
        value: function xs() {
          var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var callback = arguments.length > 1 ? arguments[1] : undefined;
          var index, j, length, ref, response, result;
          string = _.forceString(string);

          if (-1 === (length = string.length - 1)) {
            return '';
          }

          callback = _.forceFunction(callback, function (_char5) {
            return _char5;
          });
          result = '';

          for (index = j = 0, ref = length; 0 <= ref ? j <= ref : j >= ref; index = 0 <= ref ? ++j : --j) {
            if (response = callback(string[index], index)) {
              if (response === true) {
                result += string[index];
              } else if (_.isStringOrNumber(response)) {
                result += response;
              }
            }
          }

          return result;
        }
      }, {
        key: "copy",
        value: function copy(string, offset, amount) {
          offset = _.forceNumber(offset);

          if ('' === (string = _.forceString(string)) || Math.abs(offset) > string.length) {
            return '';
          }

          if (offset > 0) {
            offset -= 1;
          }

          return string.substr(offset, _.forceNumber(amount, string.length));
        }
      }, {
        key: "replace",
        value: function replace() {
          var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var toReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'g';
          var ref;

          if (!(_.isStringOrNumber(string) && ((ref = _["typeof"](toReplace)) === 'string' || ref === 'number' || ref === 'regexp'))) {
            return _.forceString(string);
          }

          if (_.notRegExp(toReplace)) {
            toReplace = Strings.regEscape(toReplace + '');
            toReplace = new RegExp(toReplace, flags); // check if needed -> _.forceString flags
          }

          return (string + '').replace(toReplace, replacement);
        }
      }, {
        key: "trim",
        value: function trim(string) {
          return Strings.replace(string, /^\s+|\s+$/g);
        }
      }, {
        key: "trimLeft",
        value: function trimLeft(string) {
          return Strings.replace(string, /^\s+/g);
        }
      }, {
        key: "trimRight",
        value: function trimRight(string) {
          return Strings.replace(string, /\s+$/g);
        }
      }, {
        key: "oneSpace",
        value: function oneSpace(string) {
          return Strings.replace(string, /\s+/g, ' ');
        }
      }, {
        key: "oneSpaceAndTrim",
        value: function oneSpaceAndTrim(string) {
          return Strings.oneSpace(Strings.trim(string));
        }
      }, {
        key: "toCamel",
        value: function toCamel(string, _char6) {
          var match;
          string = _.forceString(string);
          _char6 = _.forceString(_char6, '-');
          match = new RegExp(Strings.regEscape(_char6) + '([a-z])', 'ig');
          return Strings.replace(string, match, function (all, found) {
            return found.toUpperCase();
          });
        }
      }, {
        key: "unCamel",
        value: function unCamel(string, insertion) {
          string = _.forceString(string);
          insertion = _.forceString(insertion, '-');
          return Strings.replace(string, /([A-Z])/g, insertion + '$1').toLowerCase();
        }
      }, {
        key: "shuffle",
        value: function shuffle(string) {
          string = _.forceString(string);
          return _.shuffleArray((string + '').split('')).join('');
        }
      }, {
        key: "find",
        value: function find(string, toFind, flags) {
          var indices, result;
          indices = [];

          if ('' === (string = _.forceString(string))) {
            return indices;
          }

          flags = _.forceString(flags, 'g');

          if (_.isStringOrNumber(toFind)) {
            toFind = new RegExp(Strings.regEscape(toFind + ''), flags);
          } else if (_.isRegExp(toFind)) {
            toFind = new RegExp(toFind.source, flags);
          } else {
            return indices;
          } // check for global flag, without it a while/exec will hang the system..


          if (toFind.global) {
            while (result = toFind.exec(string)) {
              indices.push(result.index + 1);
            }
          } else {
            if (result = toFind.exec(string)) {
              indices.push(result.index + 1);
            }
          }

          return indices;
        }
      }, {
        key: "count",
        value: function count(string, toFind) {
          return Strings.find(string, toFind).length;
        }
      }, {
        key: "contains",
        value: function contains(string, substring) {
          return Strings.count(string, substring) > 0;
        }
      }, {
        key: "between",
        value: function between(string, before, after) {
          var ref, reg;

          if (!_.allStringOrNumber(string, before, after)) {
            return '';
          }

          before = Strings.regEscape(before + '');
          after = Strings.regEscape(after + '');
          reg = new RegExp(before + '(.+)' + after);
          return ((ref = reg.exec(string + '')) != null ? ref[1] : void 0) || '';
        }
      }, {
        key: "slice",
        value: function slice(string, start, size) {
          string = _.forceString(string);
          start = _.forceNumber(start || 1);

          if (false !== (start = _.positiveIndex(start, string.length))) {
            size = _.forceNumber(size);
            return string.slice(start, start + size);
          }

          return '';
        }
      }, {
        key: "truncate",
        value: function truncate(string, length, appendix) {
          string = _.forceString(string);
          length = _.forceNumber(length, string.length);
          string = Strings.slice(string, 1, length);
          return string + _.forceString(appendix);
        }
      }, {
        key: "pop",
        value: function pop(string, amount) {
          string = _.forceString(string);
          amount = _.forceNumber(amount, 1);
          return string.slice(0, -Math.abs(amount));
        }
      }, {
        key: "split",
        value: function split(string, delimiter) {
          var array, j, len, result, word;
          string = Strings.oneSpaceAndTrim(string);
          result = [];

          if (string.length < 1) {
            return result;
          }

          delimiter = _.forceString(delimiter, ' ');
          array = string.split(delimiter[0] || '');

          for (j = 0, len = array.length; j < len; j++) {
            word = array[j];

            if (word.match(/^\s$/)) {
              continue;
            }

            result.push(Strings.trim(word));
          }

          return result;
        }
      }, {
        key: "reverse",
        value: function reverse() {
          var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var ch, j, length, ref, reversed;
          string = _.forceString(string);

          if ((length = string.length - 1) < 1) {
            return string;
          }

          reversed = '';

          for (ch = j = ref = length; ref <= 0 ? j <= 0 : j >= 0; ch = ref <= 0 ? ++j : --j) {
            reversed += string[ch];
          }

          return reversed;
        }
      }, {
        key: "upper",
        value: function upper(string) {
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }

          return changeCase.apply(void 0, [string, 'toUpperCase'].concat(args));
        }
      }, {
        key: "lower",
        value: function lower(string) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return changeCase.apply(void 0, [string, 'toLowerCase'].concat(args));
        }
      }, {
        key: "insert",
        value: function insert(string, insertion) {
          for (var _len5 = arguments.length, positions = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
            positions[_key5 - 2] = arguments[_key5];
          }

          var index, j, posCount, ref;

          if ('' === (string = _.forceString(string)) || '' === (insertion = _.forceString(insertion))) {
            return string;
          }

          positions = _.sortNoDupAndReverse(positions, string.length);
          posCount = mapStringToNumber(positions) - 1;

          if (0 > posCount) {
            return string;
          }

          for (index = j = 0, ref = posCount; 0 <= ref ? j <= ref : j >= ref; index = 0 <= ref ? ++j : --j) {
            index = positions[index];

            if (index > string.length) {
              string = string + insertion;
              continue;
            }

            string = string.substr(0, index) + insertion + string.substr(index);
          }

          return string;
        }
      }, {
        key: "removeRange",
        value: function removeRange(string, offset, amount) {
          var endpoint;
          string = _.forceString(string);

          if (string === '' || false === (offset = _.positiveIndex(offset, string.length)) || 0 > (amount = _.forceNumber(amount, 1))) {
            return string;
          }

          endpoint = offset + amount;
          return Strings.xs(string, function (_char7, index) {
            if (index < offset || index >= endpoint) {
              return true;
            }
          });
        }
      }, {
        key: "removePos",
        value: function removePos(string) {
          var pos;

          if ('' === (string = _.forceString(string))) {
            return '';
          }

          for (var _len6 = arguments.length, positions = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
            positions[_key6 - 1] = arguments[_key6];
          }

          pos = positions.map(function (value) {
            return _.positiveIndex(value, string.length);
          });
          return Strings.xs(string, function (_char8, index) {
            if (!(indexOf.call(pos, index) >= 0)) {
              return true;
            }
          });
        }
      }, {
        key: "remove",
        value: function remove() {
          var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var j, len, remove;

          for (var _len7 = arguments.length, toRemove = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
            toRemove[_key7 - 1] = arguments[_key7];
          }

          if ('' === (string = _.forceString(string)) || toRemove.length < 1) {
            return string;
          }

          for (j = 0, len = toRemove.length; j < len; j++) {
            remove = toRemove[j];
            string = Strings.replace(string, remove);
          }

          return string;
        }
      }, {
        key: "startsWith",
        value: function startsWith(string, start) {
          if ('' === (string = _.forceString(string)) || '' === (start = _.forceString(start))) {
            return false;
          }

          start = new RegExp('^' + Strings.regEscape(start));
          return start.test(string);
        }
      }, {
        key: "endsWith",
        value: function endsWith(string, ending) {
          if ('' === (string = _.forceString(string)) || '' === (ending = _.forceString(ending))) {
            return false;
          }

          ending = new RegExp(Strings.regEscape(ending) + '$');
          return ending.test(string);
        } // checks wether the count for each specific character is equal for both strings

      }, {
        key: "charactersMatch",
        value: function charactersMatch(string1, string2) {
          var _char9, j, len, pos;

          if (!_.allString(string1, string2) || string1.length !== string2.length) {
            return false;
          }

          string2 = string2.split('');

          for (j = 0, len = string1.length; j < len; j++) {
            _char9 = string1[j];

            if (!string2.length) {
              return false;
            }

            pos = string2.indexOf(_char9);

            if (pos > -1) {
              string2.splice(pos, 1);
            } else {
              return false;
            }
          }

          return true;
        } // test below this line:

      }, {
        key: "wrap",
        value: function wrap() {
          var prepend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var append = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          var wrapper;

          wrapper = function wrapper(string) {
            return Strings.create(prepend, string, append);
          };

          wrapper.wrap = function () {
            var outerPrepend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var outerAppend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            prepend = _.forceString(outerPrepend) + prepend;
            return append += _.forceString(outerAppend);
          };

          return wrapper;
        } // end of statics

      }]);

      function Strings() {
        var _this;

        _classCallCheck(this, Strings);

        _this = _super2.call(this);

        _this.set.apply(_assertThisInitialized(_this), arguments);

        _this.wrapMethod = null;
        _this.crop = _this.slice;
        return _this;
      }

      _createClass(Strings, [{
        key: "set",
        value: function set() {
          this.string = Strings.create.apply(this, arguments);
          return this;
        }
      }, {
        key: "sort",
        value: function sort() {
          this.string = Strings.sort(this.string);
          return this;
        }
      }, {
        key: "random",
        value: function random(amount, charSet) {
          this.string = Strings.random(amount, charSet);
          return this;
        }
      }, {
        key: "xs",
        value: function xs(callback) {
          this.string = Strings.xs(this.string, callback);
          return this;
        }
      }, {
        key: "times",
        value: function times() {
          var _times = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

          this.string = Strings.times(this.string, _times);
          return this;
        }
      }, {
        key: "get",
        value: function get() {
          var j, len, position, string;

          if (arguments.length > 0) {
            string = '';

            for (j = 0, len = arguments.length; j < len; j++) {
              position = arguments[j];
              position = _.positiveIndex(position, this.length);

              if (position !== false) {
                string += this.string[position];
              }
            }

            return string;
          }

          return this.string;
        }
      }, {
        key: "copy",
        value: function copy(offset, amount) {
          return Strings.copy(this.string, offset, amount);
        }
      }, {
        key: "empty",
        value: function empty() {
          return Strings.empty(this.string);
        }
      }, {
        key: "isAlpha",
        value: function isAlpha() {
          return Strings.isAlpha(this.string);
        }
      }, {
        key: "isNumeric",
        value: function isNumeric() {
          return Strings.isNumeric(this.string);
        }
      }, {
        key: "isAlphaNumeric",
        value: function isAlphaNumeric() {
          return Strings.isAlphaNumeric(this.string);
        }
      }, {
        key: "isSpecial",
        value: function isSpecial() {
          return Strings.isSpecial(this.string);
        }
      }, {
        key: "isUpper",
        value: function isUpper() {
          return Strings.isUpper(this.string);
        }
      }, {
        key: "hasUpper",
        value: function hasUpper() {
          return Strings.hasUpper(this.string);
        }
      }, {
        key: "isLower",
        value: function isLower() {
          return Strings.isLower(this.string);
        }
      }, {
        key: "isSpace",
        value: function isSpace() {
          return Strings.isSpace(this.string);
        }
      }, {
        key: "push",
        value: function push() {
          this.string = this.string + Strings.create.apply(this, arguments);
          return this;
        }
      }, {
        key: "prepend",
        value: function prepend() {
          this.string = Strings.create.apply(this, arguments) + this.string;
          return this;
        }
      }, {
        key: "pop",
        value: function pop(amount) {
          this.string = Strings.pop(this.string, amount);
          return this;
        }
      }, {
        key: "insert",
        value: function insert(string) {
          for (var _len8 = arguments.length, positions = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
            positions[_key8 - 1] = arguments[_key8];
          }

          this.string = Strings.insert.apply(Strings, [this.string, string].concat(positions));
          return this;
        }
      }, {
        key: "trim",
        value: function trim() {
          this.string = Strings.trim(this.string);
          return this;
        }
      }, {
        key: "trimLeft",
        value: function trimLeft() {
          this.string = Strings.trimLeft(this.string);
          return this;
        }
      }, {
        key: "trimRight",
        value: function trimRight() {
          this.string = Strings.trimRight(this.string);
          return this;
        }
      }, {
        key: "oneSpace",
        value: function oneSpace() {
          this.string = Strings.oneSpace(this.string);
          return this;
        }
      }, {
        key: "oneSpaceAndTrim",
        value: function oneSpaceAndTrim() {
          this.string = Strings.oneSpaceAndTrim(this.string);
          return this;
        }
      }, {
        key: "find",
        value: function find(string) {
          return Strings.find(this.string, string);
        }
      }, {
        key: "count",
        value: function count(string) {
          return Strings.count(this.string, string);
        }
      }, {
        key: "contains",
        value: function contains(string) {
          return Strings.contains(this.string, string);
        }
      }, {
        key: "between",
        value: function between(before, after) {
          return Strings.between(this.string, before, after);
        }
      }, {
        key: "slice",
        value: function slice(start, size) {
          this.string = Strings.slice(this.string, start, size);
          return this;
        }
      }, {
        key: "truncate",
        value: function truncate(size, suffix) {
          this.string = Strings.truncate(this.string, size, suffix);
          return this;
        }
      }, {
        key: "remove",
        value: function remove() {
          for (var _len9 = arguments.length, strings = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            strings[_key9] = arguments[_key9];
          }

          this.string = Strings.remove.apply(Strings, [this.string].concat(strings));
          return this;
        }
      }, {
        key: "removeRange",
        value: function removeRange(offset, amount) {
          this.string = Strings.removeRange(this.string, offset, amount);
          return this;
        }
      }, {
        key: "removePos",
        value: function removePos() {
          for (var _len10 = arguments.length, positions = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
            positions[_key10] = arguments[_key10];
          }

          this.string = Strings.removePos.apply(Strings, [this.string].concat(positions));
          return this;
        }
      }, {
        key: "replace",
        value: function replace(subString, replacement, flags) {
          this.string = Strings.replace(this.string, subString, replacement, flags);
          return this;
        }
      }, {
        key: "reverse",
        value: function reverse() {
          this.string = Strings.reverse(this.string);
          return this;
        }
      }, {
        key: "upper",
        value: function upper() {
          for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
            args[_key11] = arguments[_key11];
          }

          this.string = Strings.upper.apply(Strings, [this.string].concat(args));
          return this;
        }
      }, {
        key: "lower",
        value: function lower() {
          for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
            args[_key12] = arguments[_key12];
          }

          this.string = Strings.lower.apply(Strings, [this.string].concat(args));
          return this;
        }
      }, {
        key: "shuffle",
        value: function shuffle() {
          this.string = Strings.shuffle(this.string);
          return this;
        }
      }, {
        key: "toCamel",
        value: function toCamel(_char10) {
          this.string = Strings.toCamel(this.string, _char10);
          return this;
        }
      }, {
        key: "unCamel",
        value: function unCamel(insertion) {
          this.string = Strings.unCamel(this.string, insertion);
          return this;
        }
      }, {
        key: "startsWith",
        value: function startsWith(start) {
          return Strings.startsWith(this.string, start);
        }
      }, {
        key: "endsWith",
        value: function endsWith(ending) {
          return Strings.endsWith(this.string, ending);
        }
      }, {
        key: "charactersMatch",
        value: function charactersMatch(string) {
          return Strings.charactersMatch(this.string, string);
        }
      }, {
        key: "setWrap",
        value: function setWrap(prepend, append) {
          if (_.isNull(this.wrapMethod)) {
            this.wrapMethod = Strings.wrap(prepend, append);
          } else {
            this.wrapMethod.wrap(prepend, append);
          }

          return this;
        }
      }, {
        key: "removeWrap",
        value: function removeWrap() {
          this.wrapMethod = null;
          return this;
        }
      }, {
        key: "applyWrap",
        value: function applyWrap(prepend, append) {
          this.string = this.setWrap(prepend, append).wrap;
          this.removeWrap();
          return this;
        }
      }]);

      return Strings;
    }(Chars);

    ;
    Strings.Types = Types;
    Strings.Chars = Chars;
    return Strings;
  }.call(this);

  Object.defineProperty(Strings.prototype, '$', {
    get: function get() {
      return this.get();
    }
  });
  Object.defineProperty(Strings.prototype, 'length', {
    get: function get() {
      return this.string.length;
    }
  });
  Object.defineProperty(Strings.prototype, 'wrap', {
    get: function get() {
      if (!_.isNull(this.wrapMethod)) {
        return this.wrapMethod(this.string);
      }

      return this.string;
    }
  }); // aliases:

  Strings.crop = Strings.slice;
  Strings.prototype.crop = Strings.prototype.slice;
  Strings.prototype.append = Strings.prototype.push;

  if (typeof define !== "undefined" && define !== null && 'function' === typeof define && define.amd) {
    define('strings', [], function () {
      return Strings;
    });
  } else if (typeof module !== "undefined" && module !== null) {
    module.exports = Strings;
  } else if (typeof window !== "undefined" && window !== null) {
    window.Types = Types;
    window.Strings = Strings;
  }
}).call(void 0);